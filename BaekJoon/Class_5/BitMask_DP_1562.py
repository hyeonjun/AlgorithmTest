n = int(input())
# dp[i][j][k]: i=비트정보, j=자릿수, k=끝나는수
dp = [[[0] * 10 for _ in range(101)] for _ in range(1 << 10)]
mod = 1000000000
# 처음 시작 값을 1로 초기화
# ex) 2에서 출발하는 경우 1 << 2이고, 자릿수는 0, 끝나는 수는 2이다.
#   => dp[1 << 2][0][2] = 1
for i in range(1, 10):
    dp[1 << i][0][i] = 1

# 모든 비트에 대해 순회
# 이전 단계의 높이가 한 칸 높거나 한 칸 낮은 경우의 수를 더해야한다.
# ex) 1번째 자리가 1, 2번째 자리가 2, 3번째 자리가 3인 경우 => dp[000000111][3][3]
# dp[000000111][3][3] += dp[000000011][2][4] + dp[000000011][2][2]

# 자릿수 만큼 순회
for i in range(1, n):
    # 0 ~ 9 순회
    for e in range(10):
        # 예를 들어, i=3인 3번째 순회일 때
        # 3으로 끝났는데 비트가 000000110인 경우가 있을 때, e가 3이면서 비트가 000001110인 것을 구하고자 한다.
        # (4, 000000110) 과 (2, 000000110) 인 경우를 더 하는 수가 될 것이다.
        for bm in range(1 << 10):
            # 0과 9는 앞으로 한개, 뒤로 한개밖에 못더해줌
            print(bin(bm | (1 << e)))
            if e < 9:
            # 해당 저장된 수(bm)에 | 연산으로 0에서 1 처리   # 이전 자리수에 현재 수보다 1 더 큰 수
                dp[bm | (1 << e)][i][e] += dp[bm][i-1][e+1] % mod
            if e > 0:                       # 이전 자리수에 현재 수보다 1 더 작은 수
                dp[bm | (1 << e)][i][e] += dp[bm][i-1][e-1] % mod
print(sum(dp[1023][n-1]) % mod)
