"""
k개로 0~n까지 수를 사용하여 n을 만들 수 있는 경우의 수
덧셈의 순서가 다른 경우 다른 경의 수, 한 개의 수를 여러 번 사용 가능
   n
k  0   1   2   3   4   5   6   7   8   9   10
0  0   0   0   0   0   0   0   0   0   0   0
1  0   1   1   1   1   1   1   1   1   1   1 -> 각 n 수
2  0   2   3   4
3  0   3   6   10
4  0
5  0

n k
1 1 -> 1
2 1 -> 2
3 1 -> 3

1(01) 2 -> 01 10
2(012) 2 -> 02 20 11
3(0123) 2 -> 03 30 12 21 + 0__

1(01) 3 -> 001 010 100
2(012) 3 -> 011 101 110 002 020 200 + 100
3(0123) 3 -> 111 012 021 102 120 210 201 003 030 300 (dp[k][n] => 0+dp[2][3], dp[3][2] + 100)

dp[k][n] =
  n == 1, dp[k][n] = k개 => k=1, 1 / k=2, 01 10 / k=3, 001 010 100 / k=4, 0001 0010 0100 1000 / ...

1 <= i <= k, 2 <= j <= n:
  dp[i][j] = dp[i-1][j] + dp[i][j-1]
"""
n, k = map(int, input().split())
dp = [[0 for _ in range(n+1)] for _ in range(k+1)]
mod = 1000000000
for i in range(1, k+1):
    dp[i][1] = i

for i in range(1, k+1):
    for j in range(2, n+1):
        dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod

print(dp[k][n] % mod)